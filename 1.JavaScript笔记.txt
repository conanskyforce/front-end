JavaScript数据类型

字符串(转义字符反斜杠 \,es6增加多行字符串``,${var},)
数字(整数，浮点数，科学计数法，负数，NaN，Infinidy，0x554)
布尔(&&,||,!,>,<,==,===,!=,!==,)的结果
null(空)
undefined(申明了，但是未定义)
对象(数组，函数，对象(每个键都是字符串,in 判断属性在不在某个变量(或其原型,判断是否自身才有obj.hasOwnProperty(prop))))

x=0;
switch(x){
    case 1:alert('Monday!');
       break;
    case 2:alert('Tuesday!');
    default:alert('Noday!')
}

For/In 循环
var obj= {stu1:"conan",stu2:"steve",stu3:"kite"}

for(var x in obj){

console.log(x)
}

stu1
stu2
stu3

！！实际循环的是下标

JavaScript错误处理
try{
var asd = s;
throw "err defined by me."
}
catch(err){
alert(err)
}

JavaScript对象的属性必须是字符串,针对这种情况，es6新推出了Map,Set结构.
Map 键值对结构,具有极快的查找速度
var myMap = new Map();
var name = ['jack','pony','mason']
var age = [48,42,49];
myMap.set(name[0],age[0]);
myMap.set(name[1],age[1]);
myMap.set(name[2],age[2]);

myMap.has('jack') ;//true
myMap.get('jack') ;//48

Set 与 Map 类似，但是Set不能储存value，不能储存重复的key

var mySet = new Set();
mySet.add(1);
mySet.add('1');
mySet.add(1);
mySet.add(2);
mySet.add('ok');
mySet;

Array,Map,Set 都属于 `iterable` 类型
for of 

forEach(fucntion([element,value,value],[index,key,value],[arr,Map,Set]){
	//...
})

函数内部关键字
arguments(类数组,保存传入函数的所有参数)

es6  rest 参数(数组)
function myFunc(a,b,...rest)

变量提升
在函数内部，将所有申明的变量，提升到函数头部，
所以一定要在函数的头部，申明所有的变量

let 申明变量 只在作用域生效
比如：for，不会变量提升(const　也一样)
function a(){
var a='1';
console.log(a+b);
let b = '2';//ReferenceError: b is not defined

}
a();//

const 定义一个不变的量，必须赋予初始值

'use strict';//模式修复一些小错误，变量必须var申明，函数内部的this指向undefined。
*第二层函数内部，要先捕获外层this,外层var that = this;*

apply(第一个参数是要绑定this的对象，第二个是传入函数的参数(数组))
call(第一个参数是要绑定this的对象，第二个是传入函数的参数(依次传入))

func.apply(obj,[params...])

map, reduce

[1,2,3,4,5].map(String);//["1", "2", "3", "4", "5"]
[1,2,3,4,5].map(function(x){return (x).toString()});//["1", "2", "3", "4", "5"]
[1,2,3,4,5].map(function(x){
	return x.toString();
})
[1,2,4,5,4,5,8,9].filter(function(e,i,a){return a.indexOf(e)===i})

["1", "2", "3", "4", "5"].reduce(function(x,y){return x+y});//"12345";

创建一个匿名函数并立即执行的办法,直接写语法解析会报错
(function(x){
	return x*x;
}(5));

(function(x){
	return Math.pow(x,2)
})(9);

箭头函数(相当于匿名函数,简单，并且修复了this指向问题(词法作用域，指向外层调用者))
x => x*x;
等价于
function(x){
	return x*x;
}

generator 

function* foo(x){
	yield x*x;
	yield x*x*x;
	return x**x;
}
var r = foo(3);
r;
r.next();
r.next();
r.next();

for(let a of r){
	console.log(a)
}
//循环yield的结果

generator可以在执行中多次返回，看上去就像一个可以记住执行状态的函数，generator的大用处在针对异步代码

parseInt() parseFloat() 转换到number类型
String() 或者自带的toString() 转换到string类型
typeof 可判断出number string boolean function undefined,判断不了null,数组和一般对象
Array用Array.isArray(arr) 判断
null 用 ele===null 判断
判断是否是全局对象 typeof window.someEle==='undefined'
判断某个变量是否存在用 typeof ele ==='undefined';

Object.create(ob);//创建一个基于ob原型的新对象 
var a = [];
a.__proto__ === Array.prototype;//true
原型链
a-->Array.prototype-->Object.prototyp-->null

alert.__proto__===Object.getPrototypeOf(alert);//true
Object.getPrototypeOf(alert)===Function.prototype;//true

function Structfunc(){
	this.x = 1;
	this.y = 2;
}

var x = new Structfunc();
x.x;//1
x.y;//2
原型链
x-->Structfunc.prototype-->Object.prototype-->null;
x同时获得一个constructor属性
x.constructor === Structfunc.prototype.constructor;//true
x.constructor === Structfunc;//true
x instanceof Structfunc;
x instanceof Object;

继承
function inherits(Child,Parent){
	var F = function(){};
	F.prototype = Parent.prototype;
	Child.prototype = new F();
	Child.prototype.constructor = Child;
}

es6 class
class Student{
	constructor(name){
	this.name = name;
	}
	otherfunc(){
	console.log(this.name)
	}
}
var x = new Student('666');
x.otherfunc();//666

class ExtendsStudent extends Student{
	constructor(name,grade){
	super(name);
	this.grade = grade;
	}
	myGrade(){
		return function(){console.log(this.grade)};
	}
}
var extStu = new ExtendsStudent('conan',99);
extStu.myGrade();//99



onsubmit ="return false"

onchange (元素被改变，然后失去焦点的时候触发)

<form action="xxx.xx" method="POST" onsubmit="return false">
<input type="text" name="text1">

<input type="submit" value="submit">
</form>



typeof new Boolean('asd')//构造函数 objet
typeof Boolean('asd')//转换函数 boolean

0，-0，null，''，false，undefined,NaN ————对象为false


Date()返回一个字符串
new Date()返回一个Date对象,值与Date()返回值一样

function getLocalTime(){
var d = new Date(),
    year = d.getFullYear(),
    month = d.getMonth(),
    date = d.getDate(),
    day = d.getDay(),
    hour = d.getHours(),
    min = d.getMinutes(),
    sec = d.getSeconds(),
    localTime = year+"年"+(month-0+1)+"月"+date+"日 " +hour+":"+min+":"+sec
console.log(localTime)
}
getLocalTime()

//获取UTC时间
function getUTCTime(){
var d = new Date(),
    year = d.getFullYear(),
    month = d.getMonth(),
    date = d.getUTCDate(),
    day = d.getUTCDay(),
    hour = d.getUTCHours(),
    min = d.getUTCMinutes(),
    sec = d.getUTCSeconds(),
    localTime = year+"年"+(month-0+1)+"月"+date+"日 " +hour+":"+min+":"+sec
console.log(localTime)
}
getUTCTime()


Math.random() ———>[0,1)

[97，130]

Math.floor(Math.random()*34)+97


随机获取[min,max]范围内的整数
Math.floor(Math.random()*(max-min+1)+mimn);


String
var s = "qwertyuiop";

s.charAt(0)//q
s.charCodeAt(0)//113
String.fromCharCode(113)//q

match全局匹配返回的是匹配到的子串
match非全局匹配，匹配到的是数组，第一个元素时匹配到的子串，index是文字，input是匹配元素

正则表达式

RegExp自己的方法

test()//返回true或false
exec()//返回匹配到的信息，匹配不到返回null

字符串的方法
search()//返回出现位置
match()//返回数组，已说明过
replace()
split()


encodeURI处理整个URI
encodeURIComponent处理query那部分字符串

decodeURIComponent能解码所有哦！

浏览器窗口的宽高(去除菜单栏，工具栏，边框的宽高)
window.innerHeight
window.innerWidth

document.documentElement.clientHeight
document.documentElement.clientWidth

服务端设置cookie，使用httpOnly，使得cookie只能通过浏览器获得

innerText不返回隐藏的原物文本
textContent返回所有文本
cssText css样式文本

提交表单
form 元素有一个submit方法
form本身的onsubmit事件
name属性会被提交给后台

<form action="#" enctype="multipart/form-data">
<input type="file" name="fileUpload"	/>

</form>

var file = document.getElementsByName('fileUpload')[0];

file.files[0].name;//名字
file.files[0].size;//大小字节
file.files[0].type;//类型

var reader = new FileReader();//读取文件接口
reader.onload = function(e){
	var data = e.target.result;
	preview.style.backgroundImage = 'url('+data+')';
}
reader.readAsDataURL(file);

AJAX

var request = new XMLHttpRequest();
request.onreadystatechange = function (){
	if(request.readyState == 4){
		if(request.status === 200){
			return success(request.responseText);
		}else{
			return fail(request.status);
		}
	}
}
request.open('GET','apiUrl');
request.send();

var req = new XMLHttpRequest()||new ActiveXObject('Microsoft.XMLHTTP');
req.onreadystatechange = function (e) {
	if(req.readyState ===4 &&req.status ===200){
		console.log(e);
		console.log(req);
		console.log("req.responseText: "+req.responseText);
	}
}
req.open('GET','https://httpbin.org/ip',true);//默认用异步
req.send();

跨域
JSONP
函数调用的形式返回，预先在页面中准备好回调函数
数据回来就相当于直接执行回调函数

CORS
Access-Control-Allow-Origin 包含本域就能够给跨域请求成功

Promise

new Promise(func)
.then(function(res){
	//do sth if success;
})
.catch(function(res){
	//do sth if failed;
})

































